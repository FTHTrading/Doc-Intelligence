// ─────────────────────────────────────────────────────────────
// DOCX Export — Generate editable Word documents
// ─────────────────────────────────────────────────────────────

import fs from "fs";
import path from "path";
import { DocumentObject, Section } from "../schema/documentSchema";

/**
 * Export a DocumentObject as a minimal DOCX-compatible XML.
 *
 * Note: For production, consider using a dedicated library like `docx`
 * (npm install docx). This implementation creates a basic Word XML that
 * can be opened by Word, LibreOffice, and Google Docs.
 */
export async function exportDOCX(
  doc: DocumentObject,
  outputDir: string,
  options?: { filename?: string }
): Promise<string> {
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true });
  }

  const baseName = options?.filename || sanitizeFilename(doc.metadata.title);
  const docxPath = path.join(outputDir, `${baseName}.xml`);

  const xml = generateWordXML(doc);
  fs.writeFileSync(docxPath, xml, "utf-8");

  console.log(`[EXPORT] DOCX (XML) → ${docxPath}`);
  return docxPath;
}

/** Generate Word-compatible XML from DocumentObject */
function generateWordXML(doc: DocumentObject): string {
  const bodyContent = doc.structure.map((s) => renderSectionAsWordXML(s)).join("\n");

  return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<?mso-application progid="Word.Document"?>
<w:wordDocument xmlns:w="http://schemas.microsoft.com/office/word/2003/wordml"
  xmlns:wx="http://schemas.microsoft.com/office/word/2003/auxHint"
  xmlns:o="urn:schemas-microsoft-com:office:office">
  <o:DocumentProperties>
    <o:Title>${escapeXml(doc.metadata.title)}</o:Title>
    <o:Author>Document Intelligence Engine</o:Author>
    <o:Created>${doc.metadata.ingestedAt}</o:Created>
  </o:DocumentProperties>
  <w:body>
    <!-- Document Title -->
    <w:p>
      <w:pPr>
        <w:jc w:val="center"/>
        <w:pStyle w:val="Heading1"/>
      </w:pPr>
      <w:r>
        <w:rPr><w:b/><w:sz w:val="48"/></w:rPr>
        <w:t>${escapeXml(doc.metadata.title)}</w:t>
      </w:r>
    </w:p>

    <!-- Spacer -->
    <w:p><w:r><w:t></w:t></w:r></w:p>

${bodyContent}

    <!-- Footer -->
    <w:p>
      <w:pPr><w:jc w:val="center"/></w:pPr>
      <w:r>
        <w:rPr><w:sz w:val="18"/><w:color w:val="999999"/></w:rPr>
        <w:t>Generated by Document Intelligence Engine</w:t>
      </w:r>
    </w:p>
  </w:body>
</w:wordDocument>`;
}

/** Render a section as Word XML */
function renderSectionAsWordXML(section: Section): string {
  let xml = "";

  switch (section.type) {
    case "header":
      xml = `    <w:p>
      <w:pPr><w:pStyle w:val="Heading1"/><w:jc w:val="center"/></w:pPr>
      <w:r><w:rPr><w:b/><w:sz w:val="40"/></w:rPr><w:t>${escapeXml(section.label)}</w:t></w:r>
    </w:p>`;
      break;

    case "subheader":
      xml = `    <w:p>
      <w:pPr><w:pStyle w:val="Heading2"/></w:pPr>
      <w:r><w:rPr><w:b/><w:sz w:val="32"/></w:rPr><w:t>${escapeXml(section.label)}</w:t></w:r>
    </w:p>`;
      break;

    case "paragraph":
      xml = `    <w:p>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t></w:t></w:r>
    </w:p>`;
      break;

    case "numbered-item":
      xml = `    <w:p>
      <w:pPr><w:ind w:left="720"/></w:pPr>
      <w:r><w:rPr><w:b/><w:sz w:val="24"/></w:rPr><w:t>${escapeXml(section.label)} </w:t></w:r>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t></w:t></w:r>
    </w:p>`;
      break;

    case "bulleted-item":
      xml = `    <w:p>
      <w:pPr><w:ind w:left="720"/></w:pPr>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t>• </w:t></w:r>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t></w:t></w:r>
    </w:p>`;
      break;

    case "field":
      xml = `    <w:p>
      <w:r><w:rPr><w:b/><w:sz w:val="22"/></w:rPr><w:t>${escapeXml(section.label)}: </w:t></w:r>
      <w:r><w:rPr><w:sz w:val="22"/><w:u w:val="single"/></w:rPr><w:t>                              </w:t></w:r>
    </w:p>`;
      break;

    case "signature-block":
      xml = `    <w:p><w:r><w:t></w:t></w:r></w:p>
    <w:p><w:r><w:t></w:t></w:r></w:p>
    <w:p>
      <w:r><w:rPr><w:sz w:val="22"/></w:rPr><w:t>_______________________________</w:t></w:r>
    </w:p>
    <w:p>
      <w:r><w:rPr><w:sz w:val="18"/><w:color w:val="888888"/></w:rPr><w:t>${escapeXml(section.label || "Signature")}                    Date: ___________</w:t></w:r>
    </w:p>`;
      break;

    case "divider":
      xml = `    <w:p>
      <w:pPr><w:pBdr><w:bottom w:val="single" w:sz="6" w:space="1" w:color="CCCCCC"/></w:pBdr></w:pPr>
      <w:r><w:t></w:t></w:r>
    </w:p>`;
      break;

    case "checkbox":
      xml = `    <w:p>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t>☐ </w:t></w:r>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t></w:t></w:r>
    </w:p>`;
      break;

    default:
      xml = `    <w:p>
      <w:r><w:rPr><w:sz w:val="24"/></w:rPr><w:t></w:t></w:r>
    </w:p>`;
  }

  // Render children
  if (section.children.length > 0) {
    xml += "\n" + section.children.map((c) => renderSectionAsWordXML(c)).join("\n");
  }

  return xml;
}

/** Escape XML special characters */
function escapeXml(str: string): string {
  return str
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/"/g, "&quot;")
    .replace(/'/g, "&apos;");
}

/** Sanitize filename */
function sanitizeFilename(name: string): string {
  return name
    .replace(/[^a-zA-Z0-9\s\-_]/g, "")
    .replace(/\s+/g, "-")
    .toLowerCase()
    .substring(0, 80) || "template";
}
